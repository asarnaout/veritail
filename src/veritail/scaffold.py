"""Scaffolding helpers for bootstrapping veritail projects."""

from __future__ import annotations

from pathlib import Path

DEFAULT_ADAPTER_FILENAME = "adapter.py"
DEFAULT_QUERIES_FILENAME = "queries.csv"

ADAPTER_TEMPLATE = """\
\"\"\"Generated by `veritail init`.

This adapter uses a real HTTP request pattern. Update the endpoint, auth,
and field mapping to match your search API response schema.
\"\"\"

from __future__ import annotations

import json
import os
from typing import Any
from urllib.parse import urlencode
from urllib.request import Request, urlopen

from veritail import SearchResult


SEARCH_API_URL = os.getenv("SEARCH_API_URL", "https://api.example.com/search")
SEARCH_API_KEY = os.getenv("SEARCH_API_KEY", "")


def _extract_items(payload: Any) -> list[dict[str, Any]]:
    \"\"\"Handle common response shapes: list or dict with items/results/products.\"\"\"
    if isinstance(payload, list):
        return [item for item in payload if isinstance(item, dict)]

    if isinstance(payload, dict):
        for key in ("results", "items", "products", "data"):
            value = payload.get(key)
            if isinstance(value, list):
                return [item for item in value if isinstance(item, dict)]

    return []


def _to_float(value: Any, default: float = 0.0) -> float:
    try:
        return float(value)
    except (TypeError, ValueError):
        return default


def search(query: str) -> list[SearchResult]:
    \"\"\"Fetch products from your API and map them to SearchResult.\"\"\"
    params = urlencode({"q": query, "limit": 10})
    url = f"{SEARCH_API_URL}?{params}"

    headers = {"Accept": "application/json"}
    if SEARCH_API_KEY:
        headers["Authorization"] = f"Bearer {SEARCH_API_KEY}"

    request = Request(url, headers=headers, method="GET")
    try:
        with urlopen(request, timeout=10) as response:
            raw_body = response.read().decode("utf-8")
    except Exception as exc:
        raise RuntimeError(f"Search request failed: {exc}") from exc

    try:
        payload = json.loads(raw_body)
    except json.JSONDecodeError as exc:
        raise RuntimeError("Search API response was not valid JSON.") from exc

    items = _extract_items(payload)
    results: list[SearchResult] = []
    for position, item in enumerate(items):
        product_id = str(item.get("id") or item.get("product_id") or f"row-{position}")
        title = str(item.get("title") or item.get("name") or "").strip()
        if not title:
            continue

        attributes = item.get("attributes")
        if not isinstance(attributes, dict):
            attributes = {}

        results.append(
            SearchResult(
                product_id=product_id,
                title=title,
                description=str(item.get("description") or ""),
                category=str(item.get("category") or item.get("department") or "Unknown"),
                price=_to_float(item.get("price")),
                position=position,
                image_url=str(item.get("image_url")) if item.get("image_url") else None,
                attributes=attributes,
                in_stock=bool(item.get("in_stock", True)),
            )
        )

    return results
"""

QUERIES_TEMPLATE = """\
query,type,category
running shoes,broad,Shoes
nike air max 90,navigational,Shoes
waterproof trail running shoes size 10,long_tail,Shoes
red running shoes,attribute,Shoes
"""


def scaffold_project(
    target_dir: Path,
    adapter_name: str = DEFAULT_ADAPTER_FILENAME,
    queries_name: str = DEFAULT_QUERIES_FILENAME,
    force: bool = False,
) -> tuple[Path, Path]:
    """Create starter adapter and query files for a new project."""
    if not adapter_name.endswith(".py"):
        raise ValueError("--adapter-name must end with .py")
    if not queries_name.endswith(".csv"):
        raise ValueError("--queries-name must end with .csv")

    target_dir.mkdir(parents=True, exist_ok=True)

    adapter_path = target_dir / adapter_name
    queries_path = target_dir / queries_name

    existing = [p for p in (adapter_path, queries_path) if p.exists()]
    if existing and not force:
        existing_names = ", ".join(p.name for p in existing)
        raise FileExistsError(
            f"Refusing to overwrite existing file(s): {existing_names}. "
            "Use --force to overwrite."
        )

    adapter_path.write_text(ADAPTER_TEMPLATE, encoding="utf-8")
    queries_path.write_text(QUERIES_TEMPLATE, encoding="utf-8")

    return adapter_path, queries_path


__all__ = [
    "DEFAULT_ADAPTER_FILENAME",
    "DEFAULT_QUERIES_FILENAME",
    "scaffold_project",
]
