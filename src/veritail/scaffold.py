"""Scaffolding helpers for bootstrapping veritail projects."""

from __future__ import annotations

from pathlib import Path

DEFAULT_ADAPTER_FILENAME = "adapter.py"
DEFAULT_QUERIES_FILENAME = "queries.csv"
DEFAULT_PREFIXES_FILENAME = "prefixes.csv"

ADAPTER_TEMPLATE = """\
\"\"\"Generated by `veritail init`.

This adapter uses a real HTTP request pattern. Update the endpoint, auth,
and field mapping to match your search API response schema.
\"\"\"

from __future__ import annotations

import json
import os
from typing import Any
from urllib.parse import urlencode
from urllib.request import Request, urlopen

from veritail import SearchResponse, SearchResult


SEARCH_API_URL = os.getenv("SEARCH_API_URL", "https://api.example.com/search")
SEARCH_API_KEY = os.getenv("SEARCH_API_KEY", "")


def _extract_items(payload: Any) -> list[dict[str, Any]]:
    \"\"\"Handle common response shapes: list or dict with items/results/products.\"\"\"
    if isinstance(payload, list):
        return [item for item in payload if isinstance(item, dict)]

    if isinstance(payload, dict):
        for key in ("results", "items", "products", "data"):
            value = payload.get(key)
            if isinstance(value, list):
                return [item for item in value if isinstance(item, dict)]

    return []


def _to_float(value: Any, default: float = 0.0) -> float:
    try:
        return float(value)
    except (TypeError, ValueError):
        return default


def search(query: str) -> SearchResponse:
    \"\"\"Fetch products from your API and map them to SearchResult.\"\"\"
    params = urlencode({"q": query, "limit": 10})
    url = f"{SEARCH_API_URL}?{params}"

    headers = {"Accept": "application/json"}
    if SEARCH_API_KEY:
        headers["Authorization"] = f"Bearer {SEARCH_API_KEY}"

    request = Request(url, headers=headers, method="GET")
    try:
        with urlopen(request, timeout=10) as response:
            raw_body = response.read().decode("utf-8")
    except Exception as exc:
        raise RuntimeError(f"Search request failed: {exc}") from exc

    try:
        payload = json.loads(raw_body)
    except json.JSONDecodeError as exc:
        raise RuntimeError("Search API response was not valid JSON.") from exc

    items = _extract_items(payload)
    results: list[SearchResult] = []
    for position, item in enumerate(items):
        product_id = str(item.get("id") or item.get("product_id") or f"row-{position}")
        title = str(item.get("title") or item.get("name") or "").strip()
        if not title:
            continue

        attributes = item.get("attributes")
        if not isinstance(attributes, dict):
            attributes = {}

        results.append(
            SearchResult(
                product_id=product_id,
                title=title,
                description=str(item.get("description") or ""),
                category=str(
                    item.get("category") or item.get("department") or "Unknown"
                ),
                price=_to_float(item.get("price")),
                position=position,
                attributes=attributes,
                in_stock=bool(item.get("in_stock", True)),
            )
        )

    return SearchResponse(results=results)
    # To report autocorrect / "did you mean" corrections, use:
    # return SearchResponse(results=results, corrected_query="corrected query text")
"""

QUERIES_TEMPLATE = """\
query,type,category
running shoes,broad,Shoes
nike air max 90,navigational,Shoes
waterproof trail running shoes size 10,long_tail,Shoes
red running shoes,attribute,Shoes
"""

SUGGEST_FUNCTION_TEMPLATE = """

# ---------------------------------------------------------------------------
# Autocomplete / type-ahead (generated by `veritail init --autocomplete`)
# ---------------------------------------------------------------------------

from veritail import AutocompleteResponse  # noqa: E402

SUGGEST_API_URL = os.getenv("SUGGEST_API_URL", "https://api.example.com/suggest")
SUGGEST_API_KEY = os.getenv("SUGGEST_API_KEY", "")


def _extract_suggestions(payload: Any) -> list[str]:
    \"\"\"Handle common response shapes for autocomplete APIs.\"\"\"
    if isinstance(payload, list):
        return [str(s) for s in payload if isinstance(s, str)]

    if isinstance(payload, dict):
        for key in ("suggestions", "completions", "results", "items", "data"):
            value = payload.get(key)
            if isinstance(value, list):
                return [str(s) for s in value if isinstance(s, str)]

    return []


def suggest(prefix: str) -> AutocompleteResponse:
    \"\"\"Fetch autocomplete suggestions for a prefix.\"\"\"
    params = urlencode({"q": prefix, "limit": 10})
    url = f"{SUGGEST_API_URL}?{params}"

    headers = {"Accept": "application/json"}
    if SUGGEST_API_KEY:
        headers["Authorization"] = f"Bearer {SUGGEST_API_KEY}"

    request = Request(url, headers=headers, method="GET")
    try:
        with urlopen(request, timeout=10) as response:
            raw_body = response.read().decode("utf-8")
    except Exception as exc:
        raise RuntimeError(f"Suggest request failed: {exc}") from exc

    try:
        payload = json.loads(raw_body)
    except json.JSONDecodeError as exc:
        raise RuntimeError("Suggest API response was not valid JSON.") from exc

    return AutocompleteResponse(suggestions=_extract_suggestions(payload))
"""

PREFIXES_TEMPLATE = """\
prefix,type
run,short_prefix
runnin,mid_prefix
running sh,long_prefix
nike,short_prefix
nike air,mid_prefix
nike air max,long_prefix
"""


def scaffold_project(
    target_dir: Path,
    adapter_name: str = DEFAULT_ADAPTER_FILENAME,
    queries_name: str = DEFAULT_QUERIES_FILENAME,
    force: bool = False,
    autocomplete: bool = False,
) -> tuple[Path, ...]:
    """Create starter adapter and query files for a new project.

    When autocomplete=True, appends a suggest() function to the adapter and
    generates prefixes.csv.
    """
    if not adapter_name.endswith(".py"):
        raise ValueError("--adapter-name must end with .py")
    if not queries_name.endswith(".csv"):
        raise ValueError("--queries-name must end with .csv")

    target_dir.mkdir(parents=True, exist_ok=True)

    adapter_path = target_dir / adapter_name
    queries_path = target_dir / queries_name

    all_paths = [adapter_path, queries_path]
    if autocomplete:
        all_paths.append(target_dir / DEFAULT_PREFIXES_FILENAME)

    existing = [p for p in all_paths if p.exists()]
    if existing and not force:
        existing_names = ", ".join(p.name for p in existing)
        raise FileExistsError(
            f"Refusing to overwrite existing file(s): {existing_names}. "
            "Use --force to overwrite."
        )

    adapter_content = ADAPTER_TEMPLATE
    if autocomplete:
        adapter_content += SUGGEST_FUNCTION_TEMPLATE
    adapter_path.write_text(adapter_content, encoding="utf-8")
    queries_path.write_text(QUERIES_TEMPLATE, encoding="utf-8")

    if autocomplete:
        prefixes_path = target_dir / DEFAULT_PREFIXES_FILENAME
        prefixes_path.write_text(PREFIXES_TEMPLATE, encoding="utf-8")
        return adapter_path, queries_path, prefixes_path

    return adapter_path, queries_path


__all__ = [
    "DEFAULT_ADAPTER_FILENAME",
    "DEFAULT_QUERIES_FILENAME",
    "DEFAULT_PREFIXES_FILENAME",
    "scaffold_project",
]
